using System.Collections.Concurrent;
using System.Text.Json;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Nito.AsyncEx;
using SIL.Harmony.Changes;
using SIL.Harmony.Db;

namespace SIL.Harmony;

public record SyncResults(Commit[] MissingFromLocal, Commit[] MissingFromRemote, bool IsSynced);

public class DataModel : ISyncable, IAsyncDisposable
{
    /// <summary>
    /// after adding any commit validate the commit history, not great for performance but good for testing.
    /// </summary>
    private bool AlwaysValidate => _crdtConfig.Value.AlwaysValidateCommits;

    private readonly CrdtRepositoryFactory _crdtRepositoryFactory;
    private readonly JsonSerializerOptions _serializerOptions;
    private readonly IHybridDateTimeProvider _timeProvider;
    private readonly IOptions<CrdtConfig> _crdtConfig;
    private readonly ILogger<DataModel> _logger;

    //constructor must be internal because CrdtRepository is internal
    internal DataModel(CrdtRepositoryFactory crdtRepositoryFactory,
        JsonSerializerOptions serializerOptions,
        IHybridDateTimeProvider timeProvider,
        IOptions<CrdtConfig> crdtConfig,
        ILogger<DataModel> logger)
    {
        _crdtRepositoryFactory = crdtRepositoryFactory;
        _serializerOptions = serializerOptions;
        _timeProvider = timeProvider;
        _crdtConfig = crdtConfig;
        _logger = logger;
    }


    /// <summary>
    /// add a change to the model, snapshots will be updated
    /// </summary>
    /// <param name="clientId">
    /// Unique identifier for the client, used to determine what changes need to be synced, for a single install it should always author commits with the same client id
    /// if the client id changes too much it could slow down the sync process
    /// </param>
    /// <param name="change">change to be applied to the model</param>
    /// <param name="commitId">
    /// can be used by the application code to ensure a specific change is only applied once,
    /// for example a one time migration or update of pre seeded data in the model, a hard coded guid could be used
    /// which will ensure it's only applied once to the model, even if multiple clients update at the same time and all apply the same change.
    /// typical changes should not specify the commitId and let a new guid to be generated for each commit.
    /// This could also be useful if the application has a flaky connection with the DataModel and needs to retry the same change multiple times but ensure it's only applied once,
    /// then the guid would be generated by the application
    /// </param>
    /// <param name="commitMetadata">used to store metadata on the commit, for example app version or author id</param>
    /// <returns>the newly created commit</returns>
    public async Task<Commit> AddChange(
        Guid clientId,
        IChange change,
        Guid commitId = default,
        CommitMetadata? commitMetadata = null)
    {
        return await AddChanges(clientId, [change], commitId, commitMetadata);
    }

    public async Task AddManyChanges(Guid clientId,
        IEnumerable<IChange> changes,
        Func<CommitMetadata?> commitMetadata,
        int changesPerCommitMax = 100)
    {
        await using var repo = await _crdtRepositoryFactory.CreateRepository();
        var commits = changes
            .Chunk(changesPerCommitMax)
            .Select(chunk => NewCommit(Guid.NewGuid(), clientId, commitMetadata(), chunk))
            .ToArray();
        if (commits is []) return;
        using var locked = await repo.Lock();
        repo.ClearChangeTracker();

        await using var transaction = await repo.BeginTransactionAsync();
        var updatedCommits = await repo.AddCommits(commits);
        await UpdateSnapshots(repo, updatedCommits);
        await ValidateCommits(repo);
        await transaction.CommitAsync();
    }

    /// <inheritdoc cref="AddChange"/>
    public async Task<Commit> AddChanges(
        Guid clientId,
        IEnumerable<IChange> changes,
        Guid commitId = default,
        CommitMetadata? commitMetadata = null)
    {
        var commit = NewCommit(commitId, clientId, commitMetadata, changes);
        await Add(commit);
        return commit;
    }

    private Commit NewCommit(Guid commitId, Guid clientId, CommitMetadata? commitMetadata, IEnumerable<IChange> changes)
    {
        commitId = commitId == default ? Guid.NewGuid() : commitId;
        return new Commit(commitId)
        {
            ClientId = clientId,
            HybridDateTime = _timeProvider.GetDateTime(),
            ChangeEntities = [..changes.Select(ToChangeEntity)],
            Metadata = commitMetadata ?? new()
        };
    }

    private async Task Add(Commit commit)
    {
        await using var repo = await _crdtRepositoryFactory.CreateRepository();
        if (await repo.HasCommit(commit.Id)) return;
        using var locked = await repo.Lock();
        repo.ClearChangeTracker();

        await using var transaction = repo.IsInTransaction ? null : await repo.BeginTransactionAsync();
        var updatedCommits = await repo.AddCommit(commit);
        await UpdateSnapshots(repo, updatedCommits);

        if (AlwaysValidate) await ValidateCommits(repo);


        if (transaction is not null) await transaction.CommitAsync();
    }

    public ValueTask DisposeAsync()
    {
        return ValueTask.CompletedTask;
    }

    private static ChangeEntity<IChange> ToChangeEntity(IChange change, int index)
    {
        return new ChangeEntity<IChange>()
        {
            Change = change, CommitId = change.CommitId, EntityId = change.EntityId, Index = index
        };
    }

    async Task ISyncable.AddRangeFromSync(IEnumerable<Commit> commits)
    {
        commits = commits.ToArray();
        try
        {
            await using var repo = await _crdtRepositoryFactory.CreateRepository();
            using var locked = await repo.Lock();
            repo.ClearChangeTracker();
            _timeProvider.TakeLatestTime(commits.Select(c => c.HybridDateTime));
            var (oldestChange, newCommits) = await repo.FilterExistingCommits(commits.ToArray());
            //no changes added
            if (oldestChange is null || newCommits is []) return;

            await using var transaction = await repo.BeginTransactionAsync();
            //don't save since UpdateSnapshots will also modify newCommits with hashes, so changes will be saved once that's done
            var updatedCommits = await repo.AddCommits(newCommits, false);
            await UpdateSnapshots(repo, updatedCommits);
            await ValidateCommits(repo);
            await transaction.CommitAsync();
        }
        catch (DbUpdateException e)
        {
            _logger.LogError(e, "Failed to sync commits, check {FailedImportPath} for more details", _crdtConfig.Value.FailedSyncOutputPath);
            await DumpFailedSync(new
            {
                ExceptionMessage = e.ToString(),
                Commits = commits.DefaultOrder(),
                Objects = e.Entries.Select(entry => entry.Entity)
            });
            throw;
        }
    }

    private async Task DumpFailedSync(object data)
    {
        try
        {
            Directory.CreateDirectory(_crdtConfig.Value.FailedSyncOutputPath);
            await using var failedImport =
                File.Create(Path.Combine(_crdtConfig.Value.FailedSyncOutputPath, "last-failed-import.json"));
            await JsonSerializer.SerializeAsync(failedImport, data, _serializerOptions);
        }
        catch (Exception e)
        {
            _logger.LogError(e, "Failed to dump failed import");
        }
    }

    ValueTask<bool> ISyncable.ShouldSync()
    {
        return ValueTask.FromResult(true);
    }

    private async Task UpdateSnapshots(CrdtRepository repo, SortedSet<Commit> commitsToApply)
    {
        if (commitsToApply.Count == 0) return;
        var oldestAddedCommit = commitsToApply.First();
        await repo.DeleteStaleSnapshots(oldestAddedCommit);
        Dictionary<Guid, Guid?> snapshotLookup;
        if (commitsToApply.Count > 10)
        {
            var entityIds = commitsToApply.SelectMany(c => c.ChangeEntities.Select(ce => ce.EntityId));
            snapshotLookup = await repo.CurrentSnapshots()
                .Where(s => entityIds.Contains(s.EntityId))
                .Select(s => new KeyValuePair<Guid, Guid?>(s.EntityId, s.Id))
                .ToDictionaryAsync(s => s.Key, s => s.Value);
        }
        else
        {
            snapshotLookup = [];
        }

        var snapshotWorker = new SnapshotWorker(snapshotLookup, repo, _crdtConfig.Value);
        await snapshotWorker.UpdateSnapshots(commitsToApply);
    }

    private async Task ValidateCommits(CrdtRepository repo)
    {
        Commit? parentCommit = null;
        await foreach (var commit in repo.CurrentCommits().AsNoTracking().AsAsyncEnumerable())
        {
            var parentHash = parentCommit?.Hash ?? CommitBase.NullParentHash;
            var expectedHash = commit.GenerateHash(parentHash);
            if (commit.Hash == expectedHash && commit.ParentHash == parentHash)
            {
                parentCommit = commit;
                continue;
            }

            var actualParentCommit = await repo.FindCommitByHash(commit.ParentHash);
            var commitWithSnapshots = await repo.CurrentCommits().Include(c => c.Snapshots).SingleAsync(c => c.Id == commit.Id);
            throw new CommitValidationException(
                $"Commit {commit} does not match expected hash, parent hash [{commit.ParentHash}] !== [{parentHash}], expected parent {parentCommit?.ToString() ?? "null"} and actual parent {actualParentCommit?.ToString() ?? "null"}, with snapshots: {string.Join(", ", commitWithSnapshots.Snapshots.Select(s => s.Entity.DbObject))}");
        }
    }

    public async Task RegenerateSnapshots()
    {
        await using var repo = await _crdtRepositoryFactory.CreateRepository();
        await repo.DeleteSnapshotsAndProjectedTables();
        repo.ClearChangeTracker();
        var allCommits = await repo.CurrentCommits().AsNoTracking().ToSortedSetAsync();
        await UpdateSnapshots(repo, allCommits);
    }

    public async Task<ObjectSnapshot> GetLatestSnapshotByObjectId(Guid entityId)
    {
        await using var repo = await _crdtRepositoryFactory.CreateRepository();
        return await repo.GetCurrentSnapshotByObjectId(entityId) ??
               throw new ArgumentException($"unable to find snapshot for entity {entityId}");
    }

    public async Task<T?> GetLatest<T>(Guid objectId) where T : class
    {
        return await _crdtRepositoryFactory.Execute(repo => repo.GetCurrent<T>(objectId));
    }


    public IAsyncEnumerable<T> QueryLatest<T>(Func<IQueryable<T>, IQueryable<T>>? apply = null)
        where T : class
    {
        return QueryLatest<T, T>(apply ?? (static q => q));
    }

    public async IAsyncEnumerable<TResult> QueryLatest<T, TResult>(Func<IQueryable<T>, IQueryable<TResult>> apply) where T : class
    {
        await using var repo = await _crdtRepositoryFactory.CreateRepository();
        var q = repo.GetCurrentObjects<T>();
        if (q is IQueryable<IOrderableCrdt>)
        {
            q = q.OrderBy(o => EF.Property<double>(o, nameof(IOrderableCrdt.Order)))
                .ThenBy(o => EF.Property<Guid>(o, nameof(IOrderableCrdt.Id)));
        }

        await foreach (var result in apply(q).AsAsyncEnumerable())
        {
            yield return result;
        }
    }

    public async Task<ModelSnapshot> GetProjectSnapshot(bool includeDeleted = false)
    {
        var snapshots = await _crdtRepositoryFactory.Execute(repo => repo.CurrenSimpleSnapshots(includeDeleted).ToArrayAsync());
        return new ModelSnapshot(snapshots);
    }

    public async Task<T> GetBySnapshotId<T>(Guid snapshotId)
    {
        return await _crdtRepositoryFactory.Execute(repo => repo.GetObjectBySnapshotId<T>(snapshotId));
    }

    public async Task<Dictionary<Guid, ObjectSnapshot>> GetSnapshotsAtCommit(Commit commit)
    {
        await using var repo = await _crdtRepositoryFactory.CreateRepository();
        var repository = repo.GetScopedRepository(commit);
        var (snapshots, pendingCommits) = await repository.GetCurrentSnapshotsAndPendingCommits();

        if (pendingCommits.Count != 0)
        {
            snapshots = await SnapshotWorker.ApplyCommitsToSnapshots(snapshots,
                repository,
                pendingCommits,
                _crdtConfig.Value);
        }

        return snapshots;
    }

    public async Task<T> GetAtTime<T>(DateTimeOffset time, Guid entityId)
    {
        await using var repo = await _crdtRepositoryFactory.CreateRepository();
        var commitBefore = await repo.CurrentCommits().LastOrDefaultAsync(c => c.HybridDateTime.DateTime <= time);
        if (commitBefore is null) throw new ArgumentException("unable to find any commits");
        return await GetAtCommit<T>(commitBefore, entityId);
    }

    public async Task<T> GetAtCommit<T>(Guid commitId, Guid entityId)
    {
        await using var repo = await _crdtRepositoryFactory.CreateRepository();
        return await GetAtCommit<T>(await repo.CurrentCommits().SingleAsync(c => c.Id == commitId),
            entityId);
    }

    public async Task<T> GetAtCommit<T>(Commit commit, Guid entityId)
    {
        await using var repo = await _crdtRepositoryFactory.CreateRepository();
        var repository = repo.GetScopedRepository(commit);
        var snapshot = await repository.GetCurrentSnapshotByObjectId(entityId, false);
        ArgumentNullException.ThrowIfNull(snapshot);
        var newCommits = await repository.CurrentCommits()
            .Include(c => c.ChangeEntities)
            .WhereAfter(snapshot.Commit)
            .ToSortedSetAsync();
        if (newCommits.Count > 0)
        {
            var snapshots = await SnapshotWorker.ApplyCommitsToSnapshots(
                new Dictionary<Guid, ObjectSnapshot>([
                    new KeyValuePair<Guid, ObjectSnapshot>(snapshot.EntityId, snapshot)
                ]),
                repository,
                newCommits,
                _crdtConfig.Value);
            snapshot = snapshots[snapshot.EntityId];
        }

        return (T)snapshot.Entity.DbObject;
    }

    public async Task<SyncState> GetSyncState()
    {
        await using var repo = await _crdtRepositoryFactory.CreateRepository();
        return await repo.GetCurrentSyncState();
    }

    public async Task<ChangesResult<Commit>> GetChanges(SyncState remoteState)
    {
        await using var repo = await _crdtRepositoryFactory.CreateRepository();
        return await repo.GetChanges(remoteState);
    }

    public async Task<SyncResults> SyncWith(ISyncable remoteModel)
    {
        return await SyncHelper.SyncWith(this, remoteModel, _serializerOptions);
    }

    public async Task SyncMany(ISyncable[] remotes)
    {
        await SyncHelper.SyncMany(this, remotes, _serializerOptions);
    }
}
